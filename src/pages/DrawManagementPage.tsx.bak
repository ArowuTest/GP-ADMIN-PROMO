// src/pages/DrawManagementPage.tsx
import React, { useState, useEffect } from 'react';
import { Card, Button, Steps, message, Divider } from 'antd';
import { 
  CalendarOutlined, 
  AppstoreOutlined, 
  PlayCircleOutlined, 
  TrophyOutlined 
} from '@ant-design/icons';
import DrawCalendar from '../components/DrawManagement/DrawCalendar';
import EligibilityStats from '../components/DrawManagement/EligibilityStats';
import PrizeStructureSelector from '../components/DrawManagement/PrizeStructureSelector';
import DrawAnimation from '../components/DrawManagement/DrawAnimation';
import WinnersDisplay from '../components/DrawManagement/WinnersDisplay';
import { useDrawManagement } from '../hooks/useDrawManagement';
import { usePrizeStructure } from '../hooks/usePrizeStructure';
import { usePermission } from '../hooks/usePermission';
import './DrawManagementPage.css';

const { Step } = Steps;

/**
 * Draw Management Page Component
 */
const DrawManagementPage: React.FC = () => {
  const [currentStep, setCurrentStep] = useState<number>(0);
  const [isDrawExecuted, setIsDrawExecuted] = useState<boolean>(false);
  const { canExecuteDraw } = usePermission();
  
  // Initialize hooks
  const {
    selectedDate,
    selectedPrizeStructureId,
    eligibilityStats,
    isValidatingPrizeStructure,
    isPrizeStructureValid,
    isExecutingDraw,
    drawResult,
    winners,
    error,
    handleDateSelection,
    handlePrizeStructureSelection,
    executeDraw,
    invokeRunnerUp,
    updateWinnerPaymentStatus,
    resetDrawState
  } = useDrawManagement();
  
  const {
    prizeStructures,
    isLoading: isPrizeStructuresLoading,
    loadPrizeStructures
  } = usePrizeStructure();
  
  // Load prize structures on mount
  useEffect(() => {
    loadPrizeStructures();
  }, [loadPrizeStructures]);
  
  // Handle errors
  useEffect(() => {
    if (error) {
      message.error(error);
    }
  }, [error]);
  
  // Update step when draw is executed
  useEffect(() => {
    if (drawResult && !isDrawExecuted) {
      setIsDrawExecuted(true);
      setCurrentStep(3); // Move to winners display step
    }
  }, [drawResult, isDrawExecuted]);
  
  // Handle date selection
  const onDateSelect = (date: string) => {
    handleDateSelection(date);
    if (currentStep === 0) {
      setCurrentStep(1);
    }
  };
  
  // Handle prize structure selection
  const onPrizeStructureSelect = (prizeStructureId: string) => {
    handlePrizeStructureSelection(prizeStructureId);
    if (currentStep === 1) {
      setCurrentStep(2);
    }
  };
  
  // Handle draw execution
  const onExecuteDraw = async () => {
    await executeDraw();
  };
  
  // Handle animation completion
  const onAnimationComplete = () => {
    setCurrentStep(3);
  };
  
  // Handle runner-up invocation
  const onInvokeRunnerUp = async (winnerId: string) => {
    try {
      await invokeRunnerUp(winnerId);
      message.success('Runner-up invoked successfully');
    } catch (err) {
      message.error('Failed to invoke runner-up');
    }
  };
  
  // Handle payment status update
  const onUpdatePaymentStatus = async (
    winnerId: string, 
    status: string, 
    ref?: string, 
    notes?: string
  ) => {
    try {
      await updateWinnerPaymentStatus(winnerId, status, ref, notes);
      message.success('Payment status updated successfully');
    } catch (err) {
      message.error('Failed to update payment status');
    }
  };
  
  // Handle reset
  const onReset = () => {
    resetDrawState();
    setCurrentStep(0);
    setIsDrawExecuted(false);
  };
  
  // Render step content
  const renderStepContent = () => {
    switch (currentStep) {
      case 0:
        return (
          <div className="draw-step-content">
            <DrawCalendar
              onDateSelect={onDateSelect}
              selectedDate={selectedDate}
              loading={false}
            />
          </div>
        );
      case 1:
        return (
          <div className="draw-step-content">
            <EligibilityStats
              stats={eligibilityStats}
              loading={false}
              date={selectedDate}
            />
            <PrizeStructureSelector
              prizeStructures={prizeStructures}
              selectedPrizeStructureId={selectedPrizeStructureId || undefined}
              onSelect={onPrizeStructureSelect}
              loading={isPrizeStructuresLoading || isValidatingPrizeStructure}
              isValid={isPrizeStructureValid}
              validationMessage="Selected prize structure is not valid for this date"
              selectedDate={selectedDate}
            />
          </div>
        );
      case 2:
        return (
          <div className="draw-step-content">
            <Card title="Execute Draw" className="draw-execution-card">
              <p className="draw-execution-info">
                You are about to execute a draw for <strong>{selectedDate}</strong> using the prize structure <strong>{prizeStructures.find(p => p.id === selectedPrizeStructureId)?.name}</strong>.
              </p>
              <p className="draw-execution-info">
                This will select winners from <strong>{eligibilityStats?.totalEligible || 0}</strong> eligible participants with a total of <strong>{eligibilityStats?.totalEntries || 0}</strong> entries.
              </p>
              <DrawAnimation
                onAnimationComplete={onAnimationComplete}
                autoStart={isDrawExecuted}
              />
              {!isDrawExecuted && (
                <div className="draw-execution-actions">
                  <Button
                    type="primary"
                    size="large"
                    icon={<PlayCircleOutlined />}
                    onClick={onExecuteDraw}
                    loading={isExecutingDraw}
                    disabled={!isPrizeStructureValid || !canExecuteDraw()}
                  >
                    Execute Draw
                  </Button>
                  {!canExecuteDraw() && (
                    <div className="draw-permission-warning">
                      Only Super Admin can execute draws
                    </div>
                  )}
                </div>
              )}
            </Card>
          </div>
        );
      case 3:
        return (
          <div className="draw-step-content">
            <Card title="Draw Results" className="draw-results-card">
              <div className="draw-results-header">
                <div className="draw-results-info">
                  <p>Draw Date: <strong>{selectedDate}</strong></p>
                  <p>Prize Structure: <strong>{prizeStructures.find(p => p.id === selectedPrizeStructureId)?.name}</strong></p>
                </div>
                <Button type="primary" onClick={onReset}>
                  New Draw
                </Button>
              </div>
              <Divider />
              <WinnersDisplay
                winners={winners}
                loading={false}
                onInvokeRunnerUp={onInvokeRunnerUp}
                onUpdatePaymentStatus={onUpdatePaymentStatus}
              />
            </Card>
          </div>
        );
      default:
        return null;
    }
  };
  
  return (
    <div className="draw-management-page">
      <Card title="Draw Management" className="draw-management-card">
        <Steps current={currentStep} className="draw-steps">
          <Step title="Select Date" icon={<CalendarOutlined />} />
          <Step title="Configure" icon={<AppstoreOutlined />} />
          <Step title="Execute" icon={<PlayCircleOutlined />} />
          <Step title="Winners" icon={<TrophyOutlined />} />
        </Steps>
        
        {renderStepContent()}
      </Card>
    </div>
  );
};

export default DrawManagementPage;
